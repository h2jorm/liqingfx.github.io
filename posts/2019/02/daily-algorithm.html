<!DOCTYPE html>
<html lang="en_US">

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

  <title>每日算法精练 | 李青的网络日志</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/style/normalize.css" />
  <link rel="stylesheet" type="text/css" href="/style/main.css" />

</head>

<body>
<article><h1>每日算法精练</h1><p>业精于勤荒于嬉，行成于思毁于随。每日算法写一遍，手到心到记得牢。</p>
<div id="algsBlock" style="margin: 40px 0; padding: 20px; background-color: #eee"></div>
<script src="/assets/2019/02/02/random_algs.js"></script>

<h2 id="算法列表"><a href="#算法列表">算法列表</a></h2><h3 id="栈"><a href="#栈">栈</a></h3><pre><code>class Stack:
    def __init__(self):
        self.stack = []

    def push(self, a):
        self.stack.append(a)

    def pop(self):
        return self.stack.pop()

    def peek(self):
        l = len(self.stack)
        if not l:
            return None
        else:
            return self.stack[l - 1]

    def size(self):
        return len(self.stack)</code></pre><h3 id="队列"><a href="#队列">队列</a></h3><pre><code>class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, a):
        self.stack.append(a)

    def dequeue(self):
        return self.stack.pop(0) if len(self.queue) else None

    def peek(self):
        return self.queue[0] if len(self.queue) else None

    def size(self):
        return len(self.queue))</code></pre><h3 id="链表"><a href="#链表">链表</a></h3><pre><code>class LinkNode:
    def __init__(self, val):
        self.val = val
        self.next = None

class LinkList:
    def __init__(self):
        self.head = LinkNode(None)
        self.tail = LinkNode(None)
        self.head.next = self.tail
        self.size = 0

    def _checkIndex(self, index):
        if index &lt; 0 or index &gt; self.size:
            raise IndexError(&quot;index out&quot;)

    def _findPrevNode(self, index):
        self._checkIndex(index)
        i = 0
        prev = self.head
        while index != i:
            prev = prev.next
            i += 1
        return prev

    def insert(self, node, index):
        prev = self._findPrevNode(prev)
        node.next = prev.next
        prev.next = node
        self.size += 1

    def remove(self, index):
        if not self.size():
            return None
        prev = self._findPrevNode(prev)
        ret = prev.next
        prev.next = prev.next.next
        self.size -= 1
        return ret

    def insertToLast(self, node):
        self.insert(node, self.size)

    def insertToFirst(self, node):
        self.insert(node, 0)

    def removeFirst(self):
        return self.remove(0)

    def removeLast(self):
        return self.remove(self.size() - 1)</code></pre><h3 id="并查集"><a href="#并查集">并查集</a></h3><pre><code>class DisjointSet:
    def __init__(self, n):
        self.list = list(range(n))
        self.weight = [0]*n

    def find(self, i):
        while self.list[i] != i:
            i = self.list[i]
        return i

    def union(self, i, j):
        p = self.find(i)
        q = self.find(j)
        if p == q:
            return
        if self.weight[p] &lt; self.weight[q]:
            self.list[p] = q
            self.weight[q] += self.weight[p]
        else:
            self.list[q] = p
            self.weight[p] += self.weight[q]

    def connected(self, i, j):
        return self.find(i) == self.find(j)</code></pre><h3 id="选择排序"><a href="#选择排序">选择排序</a></h3><pre><code>def selectionSort(a):
    for i in range(len(a)):
        selected = i
        for j in range(i + 1, len(a)):
            if a[j] &lt; a[selected]:
                selected = j
        a[i], a[selected] = a[selected], a[i]</code></pre><h3 id="插入排序"><a href="#插入排序">插入排序</a></h3><pre><code>def insertionSort(a):
    for i in range(1, len(a)):
        j = i
        while (j &gt; 0):
            if a[j] &lt; a[j - 1]:
                a[j-1], a[j] = a[j], a[j-1]
            j -= 1</code></pre><h3 id="归并排序"><a href="#归并排序">归并排序</a></h3><pre><code>def _mergeSort(a, lo, hi):
    if lo == hi:
        return
    if lo + 1 == hi:
        if a[lo] &gt; a[hi]:
            a[lo], a[hi] = a[hi], a[lo]
        return
    mid = int((hi - lo) / 2) + lo
    _mergeSort(a, lo, mid)
    _mergeSort(a, mid + 1, hi)
    return merge(a, lo, mid, hi)


def merge(a, lo, mid, hi):
    tmp = []
    i = lo
    j = mid + 1
    for k in range(lo, hi + 1):
        if i &gt; mid:
            tmp.append(a[j])
            j += 1
            continue
        if j &gt; hi:
            tmp.append(a[i])
            i += 1
            continue
        if a[i] &lt; a[j]:
            tmp.append(a[i])
            i += 1
        else:
            tmp.append(a[j])
            j += 1
    for k in range(len(tmp)):
        a[lo + k] = tmp[k]</code></pre><h3 id="快速排序"><a href="#快速排序">快速排序</a></h3><pre><code>def quickSort(a):
    _quickSort(a, 0, len(a) - 1)


def swap(a, i, j):
    a[i], a[j] = a[j], a[i]


def _quickSort(a, lo, hi):
    if hi &lt;= lo:
        return
    if hi - lo == 1:
        if a[lo] &gt; a[hi]:
            swap(a, lo, hi)
        return
    j = partition(a, lo, hi)
    _quickSort(a, lo, j - 1)
    _quickSort(a, j + 1, hi)


def partition(a, lo, hi):
    i, j = lo + 1, hi
    while True:
        while a[i] &lt; a[lo]:
            i += 1
        while a[j] &gt; a[lo]:
            j -= 1
        if i &gt;= j:
            break
        swap(a, i, j)
    swap(a, lo, j)
    return j</code></pre><h3 id="基于二叉堆的优先队列"><a href="#基于二叉堆的优先队列">基于二叉堆的优先队列</a></h3><pre><code>class MaxPQ:
    def __init__(self):
        self.queue = []
        pass

    def add(self, val):
        self.queue.append(val)
        self._up(self.size() - 1)
        pass

    def delMax(self):
        if not self.size():
            return None
        self._swap(0, self.size() - 1)
        ret = self.queue.pop()
        self._down(0)
        return ret

    def size(self):
        return len(self.queue)

    def peek(self, i):
        return self.queue[i]

    def _swap(self, i, j):
        self.queue[i], self.queue[j] = self.queue[j], self.queue[i]

    def _up(self, i):
        if not i:
            return
        prevIndex = int((i - 1) / 2)
        if self.queue[prevIndex] &lt; self.queue[i]:
            self._swap(prevIndex, i)
            self._up(prevIndex)

    def _down(self, i):
        lIndex = 2 * i + 1
        rIndex = 2 * i + 2
        if lIndex &gt;= len(self.queue):
            return
        if rIndex &gt;= len(self.queue):
            index = lIndex
        else:
            l = self.queue[lIndex]
            r = self.queue[rIndex]
            index = lIndex if l &gt; r else rIndex
        if self.queue[index] &gt; self.queue[i]:
            self._swap(index, i)
            self._down(index)</code></pre><h3 id="二叉查找树"><a href="#二叉查找树">二叉查找树</a></h3><p>todo</p>
<h3 id="二分查找"><a href="#二分查找">二分查找</a></h3><p>todo</p>
<h3 id="红黑树"><a href="#红黑树">红黑树</a></h3><p>todo</p>
<h3 id="基于拉链法的散列表"><a href="#基于拉链法的散列表">基于拉链法的散列表</a></h3><pre><code>class HashTable:
    def __init__(self, n=10):
        self.table = [[]] * n

    def set(self, key, val):
        hash = self.hash(key)
        index = hash % len(self.table)
        l = self.table[index]
        l.append({
            &#39;hash&#39;: hash,
            &#39;val&#39;: val
        })

    def get(self, key):
        hash = self.hash(key)
        index = hash % len(self.table)
        l = self.table[index]
        for item in l:
            if item[&#39;hash&#39;] == hash:
                return item[&#39;val&#39;]
        return None

    def delete(self, key):
        hash = self.hash(key)
        index = hash % len(self.table)
        l = self.table[index]
        for idx, item in enumerate(l):
            if item[&#39;hash&#39;] == hash:
                l.pop(idx)
                return

    def hash(self, key):
        hash = 0
        for c in key:
            hash = (hash &lt;&lt; 5) + ord(c)
        return hash</code></pre><h3 id="单词查找树"><a href="#单词查找树">单词查找树</a></h3><p>todo</p>
</article>

<footer class="blog-footer">
  <div>Post By <a href="mailto:liqing.fx@gmail.com">liqing.fx@gmail.com</a></div>
  <div>Host On <a target="_blank" href="https://github.com/liqingfx">Github</a></div>
</footer>

<a class="blog-back" href="/">Back</a>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "https://blog.liqing.name/posts/2019/02/daily-algorithm.html";
this.page.identifier = "b34fa57240e407e4f9d8844f237e324f";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://liqing-blog.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<script>
  (function() {
    var a = document.querySelector('article');
    a.addEventListener('click', function(event) {
      var target = event.target;
      if (target.tagName !== 'IMG') {
        return
      }
      newImgJumbotron(target.src);
    });
    function newImgJumbotron(imgSrc) {
      var container = document.createElement('div');
      container.className = 'img-jumbotron';
      var body = document.createElement('div');
      body.className = 'img-jumbotron-body';
      var close = document.createElement('div');
      close.innerHTML = '&times;';
      close.className = 'img-jumbotron-close';
      var img = document.createElement('img');
      img.src = imgSrc;
      body.appendChild(close);
      body.appendChild(img);
      container.appendChild(body);
      document.body.appendChild(container);
      function closeDB() {
        document.body.removeChild(container);
      }
      close.addEventListener('click', function() {
        closeDB();
      });
      container.addEventListener('click', function(event) {
        if (event.target === container) {
          closeDB();
        }
      });
      return container;
    }
  })();
</script>
</body>

</html>